"""
Accurate motor simulation for Pololu 37D 30:1 gearmotor
Based on datasheet performance curves
"""

import numpy as np
import logging

logger = logging.getLogger(__name__)


class PololuMotorModel:
    """
    Accurate simulation model for Pololu 37D Metal Gearmotor 30:1 12V
    Based on datasheet performance curves with realistic physics
    """

    def __init__(self, voltage: float = 12.0, total_gear_ratio: float = 135.0):
        """
        Initialize motor model

        Args:
            voltage: Operating voltage (12V nominal)
            total_gear_ratio: Total system gear ratio (30:1 motor × 4.5:1 external = 135:1)
        """
        self.voltage = voltage
        self.total_gear_ratio = total_gear_ratio

        # Datasheet specs for 30:1 gearmotor at 12V
        self.no_load_rpm_gearbox = 330.0  # RPM at gearbox output
        self.no_load_current = 0.2  # Amps
        self.stall_torque_kgmm = 140.0  # kg⋅mm at gearbox output
        self.stall_current = 5.5  # Amps

        # Convert to output shaft (after external 4.5:1 reduction)
        self.no_load_rpm_shaft = self.no_load_rpm_gearbox / (total_gear_ratio / 30.0)
        self.no_load_dps_shaft = self.no_load_rpm_shaft * 6.0  # deg/sec

        self.stall_torque_shaft_kgmm = self.stall_torque_kgmm * (total_gear_ratio / 30.0)

        # Motor electrical constants (derived from datasheet)
        # V = back_emf_constant * omega + I * resistance
        self.back_emf_constant = voltage / (self.no_load_rpm_gearbox * 2 * np.pi / 60)  # V/(rad/s)
        self.resistance = voltage / self.stall_current  # Ohms
        self.torque_constant = self.stall_torque_kgmm / self.stall_current  # kg⋅mm/A

        # Friction model
        self.static_friction_kgmm = 3.0  # Static friction torque
        self.kinetic_friction_kgmm = 1.5  # Kinetic friction torque
        self.viscous_damping = 0.01  # Viscous damping coefficient

        # Inertia (estimated for motor + gearbox + external gears)
        # This affects acceleration response
        self.motor_inertia = 0.0001  # kg⋅m² (motor shaft)
        self.gearbox_inertia = 0.0005  # kg⋅m² (gearbox internal)
        self.external_inertia = 0.002  # kg⋅m² (external gears + load)
        self.total_inertia = (
            self.motor_inertia +
            self.gearbox_inertia * (30**2) +
            self.external_inertia * (self.total_gear_ratio**2)
        )

        # Efficiency curve (approximate from datasheet graph)
        # Peak efficiency ~54% at 280 RPM, 18 kg⋅mm
        self.peak_efficiency = 0.54
        self.peak_efficiency_rpm = 280.0

        logger.info(f"Pololu motor model initialized: {voltage}V, {total_gear_ratio}:1 ratio")
        logger.debug(f"No-load speed: {self.no_load_dps_shaft:.2f} deg/sec")
        logger.debug(f"Stall torque: {self.stall_torque_shaft_kgmm:.1f} kg⋅mm")

    def compute_motor_torque(self, pwm: float, current_velocity_dps: float) -> float:
        """
        Compute motor torque output based on PWM and current velocity

        Args:
            pwm: PWM duty cycle (-1.0 to 1.0)
            current_velocity_dps: Current angular velocity in deg/sec

        Returns:
            Motor torque in kg⋅mm at output shaft
        """
        # Voltage applied to motor
        applied_voltage = abs(pwm) * self.voltage

        # Back-EMF (voltage generated by motor rotation)
        # Convert velocity to motor shaft RPM
        motor_shaft_rpm = abs(current_velocity_dps) / 6.0 * (self.total_gear_ratio / 30.0)
        back_emf = self.back_emf_constant * (motor_shaft_rpm * 2 * np.pi / 60)

        # Current through motor
        if applied_voltage > back_emf:
            current = (applied_voltage - back_emf) / self.resistance
        else:
            current = 0.0

        # Torque at motor shaft (before gearbox)
        motor_torque_kgmm = self.torque_constant * current

        # Torque at gearbox output
        gearbox_torque_kgmm = motor_torque_kgmm * 30.0

        # Efficiency loss through gears (helical gears are ~90% efficient per stage)
        # 30:1 gearbox has 3 stages, external 4.5:1 adds 1 stage
        total_efficiency = 0.90 ** 4  # ~0.66 efficiency
        gearbox_torque_kgmm *= total_efficiency

        # Torque at final output shaft
        output_torque_kgmm = gearbox_torque_kgmm * (self.total_gear_ratio / 30.0)

        # Apply friction losses
        if abs(current_velocity_dps) < 0.1:
            # Static friction when nearly stopped
            if output_torque_kgmm > self.static_friction_kgmm:
                output_torque_kgmm -= self.static_friction_kgmm
            elif output_torque_kgmm < -self.static_friction_kgmm:
                output_torque_kgmm += self.static_friction_kgmm
            else:
                output_torque_kgmm = 0.0  # Not enough torque to overcome static friction
        else:
            # Kinetic friction when moving
            if current_velocity_dps > 0:
                output_torque_kgmm -= self.kinetic_friction_kgmm
            else:
                output_torque_kgmm += self.kinetic_friction_kgmm

            # Viscous damping (increases with speed)
            output_torque_kgmm -= self.viscous_damping * abs(current_velocity_dps) * np.sign(current_velocity_dps)

        # Direction handling
        if pwm < 0:
            output_torque_kgmm = -output_torque_kgmm

        return output_torque_kgmm

    def compute_acceleration(self, torque_kgmm: float) -> float:
        """
        Compute angular acceleration from torque

        Args:
            torque_kgmm: Torque in kg⋅mm

        Returns:
            Angular acceleration in deg/sec²
        """
        # Convert kg⋅mm to N⋅m
        torque_nm = torque_kgmm * 0.00980665

        # Angular acceleration (rad/s²)
        alpha_rad_s2 = torque_nm / self.total_inertia

        # Convert to deg/s²
        alpha_deg_s2 = np.degrees(alpha_rad_s2)

        return alpha_deg_s2

    def get_motor_current(self, pwm: float, current_velocity_dps: float) -> float:
        """
        Estimate motor current draw

        Args:
            pwm: PWM duty cycle
            current_velocity_dps: Current velocity

        Returns:
            Current in Amps
        """
        applied_voltage = abs(pwm) * self.voltage
        motor_shaft_rpm = abs(current_velocity_dps) / 6.0 * (self.total_gear_ratio / 30.0)
        back_emf = self.back_emf_constant * (motor_shaft_rpm * 2 * np.pi / 60)

        if applied_voltage > back_emf:
            current = (applied_voltage - back_emf) / self.resistance
        else:
            current = self.no_load_current

        return current

    def get_efficiency(self, current_velocity_dps: float, torque_kgmm: float) -> float:
        """
        Estimate system efficiency

        Args:
            current_velocity_dps: Current velocity
            torque_kgmm: Output torque

        Returns:
            Efficiency (0-1)
        """
        # Approximate efficiency curve from datasheet
        # Peak at ~280 RPM gearbox output
        motor_shaft_rpm = abs(current_velocity_dps) / 6.0 * (self.total_gear_ratio / 30.0)
        gearbox_rpm = motor_shaft_rpm / 30.0

        # Gaussian-like efficiency curve
        efficiency = self.peak_efficiency * np.exp(-((gearbox_rpm - self.peak_efficiency_rpm) / 150.0)**2)

        # Reduce efficiency under heavy load
        load_fraction = abs(torque_kgmm) / self.stall_torque_shaft_kgmm
        efficiency *= (1.0 - 0.3 * load_fraction)  # 30% reduction at stall

        return max(0.1, min(0.7, efficiency))
